"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const AvoDeduplicator_1 = require("../AvoDeduplicator");
const utils_1 = require("../utils");
const AvoInspector_1 = require("../AvoInspector");
const constants_1 = require("./constants");
describe("Deduplicator", () => {
    const deduplicator = new AvoDeduplicator_1.AvoDeduplicator();
    const testObject = {
        "0": "some string",
        "1": [1, 2, 3],
        2: [["str", true]],
        3: { avo: [1.1, 2.2, 3.3] },
    };
    test(`AvoDeduplicator.deepEqual tests`, () => {
        const secondObject = {
            "0": "some string",
            "1": [1, 2, 3],
            2: [["str", true]],
            3: { avo: [1.1, 2.2, 3.3] },
        };
        expect(utils_1.deepEquals(testObject, secondObject)).toBe(true);
        expect(utils_1.deepEquals(testObject, Object.assign(Object.assign({}, secondObject), { "4": "4" }))).toBe(false);
        expect(utils_1.deepEquals(testObject, Object.assign(Object.assign({}, secondObject), { 3: Object.assign(Object.assign({}, secondObject[3]), { avo: [1.1] }) }))).toBe(false);
        expect(utils_1.deepEquals(testObject, Object.assign(Object.assign({}, secondObject), { 0: "other string" }))).toBe(false);
    });
    test(`Detects duplications when track in avo and then manually`, () => {
        const shouldRegisterFromAvo = deduplicator.shouldRegisterEvent("Test", testObject, true);
        const shouldRegisterManual = deduplicator.shouldRegisterEvent("Test", testObject, false);
        expect(shouldRegisterFromAvo).toBe(true);
        expect(shouldRegisterManual).toBe(false);
    });
    test(`Detects duplications when track manually and then in avo`, () => {
        const shouldRegisterManual = deduplicator.shouldRegisterEvent("Test", testObject, false);
        const shouldRegisterFromAvo = deduplicator.shouldRegisterEvent("Test", testObject, true);
        expect(shouldRegisterManual).toBe(true);
        expect(shouldRegisterFromAvo).toBe(false);
    });
    test(`Inspector deduplicates only one event when track manually, in avo and then manually again`, () => __awaiter(void 0, void 0, void 0, function* () {
        const inspector = new AvoInspector_1.AvoInspector(constants_1.defaultOptions);
        inspector.enableLogging(false);
        const manuallyTrackedSchema = yield inspector.trackSchemaFromEvent("test", testObject);
        // @ts-ignore
        const avoTrackedSchema = yield inspector._avoFunctionTrackSchemaFromEvent("test", testObject, "eventId", "eventhash");
        const manuallyTrackedSchemaAgain = yield inspector.trackSchemaFromEvent("test", testObject);
        expect(manuallyTrackedSchema.length).toBe(4);
        expect(avoTrackedSchema.length).toBe(0);
        expect(manuallyTrackedSchemaAgain.length).toBe(4);
    }));
    test(`Inspector deduplicates only one event when track in avo, manually and then in avo again`, () => __awaiter(void 0, void 0, void 0, function* () {
        const inspector = new AvoInspector_1.AvoInspector(constants_1.defaultOptions);
        inspector.enableLogging(false);
        // @ts-ignore
        const avoTrackedSchema = yield inspector._avoFunctionTrackSchemaFromEvent("test", testObject, "eventId", "eventhash");
        const manuallyTrackedSchema = yield inspector.trackSchemaFromEvent("test", testObject);
        // @ts-ignore
        const avoTrackedSchemaAgain = yield inspector._avoFunctionTrackSchemaFromEvent("test", testObject, "eventId", "eventhash");
        expect(avoTrackedSchema.length).toBe(4);
        expect(manuallyTrackedSchema.length).toBe(0);
        expect(avoTrackedSchemaAgain.length).toBe(4);
    }));
    test(`Allows two same manual events in a row`, () => __awaiter(void 0, void 0, void 0, function* () {
        const inspector = new AvoInspector_1.AvoInspector(constants_1.defaultOptions);
        inspector.enableLogging(false);
        const manuallyTrackedSchema = yield inspector.trackSchemaFromEvent("test", testObject);
        const manuallyTrackedSchemaAgain = yield inspector.trackSchemaFromEvent("test", testObject);
        expect(manuallyTrackedSchema.length).toBe(4);
        expect(manuallyTrackedSchemaAgain.length).toBe(4);
    }));
    test(`Allows two same avo events in a row`, () => __awaiter(void 0, void 0, void 0, function* () {
        const inspector = new AvoInspector_1.AvoInspector(constants_1.defaultOptions);
        inspector.enableLogging(false);
        // @ts-ignore
        const avoTrackedSchema = yield inspector._avoFunctionTrackSchemaFromEvent("test", testObject, "eventId", "eventhash");
        // @ts-ignore
        const avoTrackedSchemaAgain = yield inspector._avoFunctionTrackSchemaFromEvent("test", testObject, "eventId", "eventhash");
        expect(avoTrackedSchema.length).toBe(4);
        expect(avoTrackedSchemaAgain.length).toBe(4);
    }));
    test(`Does not deduplicate if more than 500ms pass`, () => {
        const shouldRegisterFromAvo = deduplicator.shouldRegisterEvent("Test", testObject, true);
        const now = new Date();
        const dateNowSpy = jest
            .spyOn(Date, "now")
            .mockImplementation(() => now.setMilliseconds(now.getMilliseconds() + 501));
        const shouldRegisterManual = deduplicator.shouldRegisterEvent("Test", testObject, false);
        expect(shouldRegisterFromAvo).toBe(true);
        expect(shouldRegisterManual).toBe(true);
        dateNowSpy.mockRestore();
    });
});
