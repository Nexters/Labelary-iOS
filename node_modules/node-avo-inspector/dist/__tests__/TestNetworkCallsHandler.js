"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const AvoGuid_1 = require("../AvoGuid");
const AvoNetworkCallsHandler_1 = require("../AvoNetworkCallsHandler");
const constants_1 = require("./constants");
const inspectorVersion = process.env.npm_package_version || "";
describe("NetworkCallsHandler", () => {
    const { apiKey, env, version } = constants_1.defaultOptions;
    const appName = "";
    let networkHandler;
    let baseBody;
    const customCallback = jest.fn();
    const now = new Date();
    beforeAll(() => {
        // @ts-ignore
        jest.spyOn(global, "Date").mockImplementation(() => now);
        jest
            .spyOn(AvoGuid_1.AvoGuid, "newGuid")
            .mockImplementation(() => constants_1.mockedReturns.GUID);
        networkHandler = new AvoNetworkCallsHandler_1.AvoNetworkCallsHandler(apiKey, env, "", version, inspectorVersion);
        baseBody = {
            apiKey,
            appName,
            appVersion: version,
            libVersion: inspectorVersion,
            env,
            libPlatform: "node",
            messageId: constants_1.mockedReturns.GUID,
            trackingId: "",
            createdAt: new Date().toISOString(),
            sessionId: constants_1.mockedReturns.SESSION_ID,
            samplingRate: 1.0,
        };
    });
    afterEach(() => {
        jest.clearAllMocks();
    });
    test("bodyForSessionStartedCall returns base body + session started body used for session started", () => {
        const body = networkHandler.bodyForSessionStartedCall(constants_1.mockedReturns.SESSION_ID);
        expect(body).toEqual(Object.assign(Object.assign({}, baseBody), { type: "sessionStarted" }));
    });
    test("bodyForEventSchemaCall returns base body + event schema used for event sending from non avo functions", () => {
        const eventName = "event name";
        const eventProperties = [{ propertyName: "prop0", propertyType: "string" }];
        const body = networkHandler.bodyForEventSchemaCall(constants_1.mockedReturns.SESSION_ID, eventName, eventProperties, null, null);
        expect(body).toEqual(Object.assign(Object.assign({}, baseBody), { type: "event", eventName,
            eventProperties, avoFunction: false, eventId: null, eventHash: null }));
    });
    test("bodyForEventSchemaCall returns base body + event schema used for event sending from avo functions", () => {
        const eventName = "event name";
        const eventId = "event id";
        const eventHash = "event hash";
        const eventProperties = [{ propertyName: "prop0", propertyType: "string" }];
        const body = networkHandler.bodyForEventSchemaCall(constants_1.mockedReturns.SESSION_ID, eventName, eventProperties, eventId, eventHash);
        expect(body).toEqual(Object.assign(Object.assign({}, baseBody), { type: "event", eventName,
            eventProperties, avoFunction: true, eventId,
            eventHash }));
    });
});
